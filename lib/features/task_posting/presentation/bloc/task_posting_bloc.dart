import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/entities/task.dart';
import '../../domain/usecases/create_task.dart';
import 'task_posting_event.dart';
import 'task_posting_state.dart';

class TaskPostingBloc extends Bloc<TaskPostingEvent, TaskPostingState> {
  final CreateTask createTask;

  TaskPostingBloc({required this.createTask}) : super(TaskPostingInitial()) {
    on<TaskPostingInitialize>(_onInitialize);
    on<TaskPostingUpdateTitle>(_onUpdateTitle);
    on<TaskPostingUpdateSummary>(_onUpdateSummary);
    on<TaskPostingUpdateCategory>(_onUpdateCategory);
    on<TaskPostingUpdateLocation>(_onUpdateLocation);
    on<TaskPostingUpdateBudget>(_onUpdateBudget);
    on<TaskPostingUpdatePreferredDate>(_onUpdatePreferredDate);
    on<TaskPostingAddImage>(_onAddImage);
    on<TaskPostingRemoveImage>(_onRemoveImage);
    on<TaskPostingSubmit>(_onSubmit);
    on<TaskPostingUpdateStep>(_onUpdateStep);
    on<TaskPostingNextStep>(_onNextStep);
    on<TaskPostingPreviousStep>(_onPreviousStep);
    on<TaskPostingReset>(_onReset);
  }

  void _onInitialize(TaskPostingInitialize event, Emitter<TaskPostingState> emit) {
    emit(TaskPostingLoaded());
  }

  void _onUpdateTitle(TaskPostingUpdateTitle event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      emit(currentState.copyWith(title: event.title));
    }
  }

  void _onUpdateSummary(TaskPostingUpdateSummary event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      emit(currentState.copyWith(summary: event.summary));
    }
  }

  void _onUpdateCategory(TaskPostingUpdateCategory event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      emit(currentState.copyWith(
        category: event.category,
        subcategory: event.subcategory,
      ));
    }
  }

  void _onUpdateLocation(TaskPostingUpdateLocation event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      emit(currentState.copyWith(location: event.location));
    }
  }

  void _onUpdateBudget(TaskPostingUpdateBudget event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      emit(currentState.copyWith(budget: event.budget));
    }
  }

  void _onUpdatePreferredDate(TaskPostingUpdatePreferredDate event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      emit(currentState.copyWith(preferredDate: event.preferredDate));
    }
  }

  void _onAddImage(TaskPostingAddImage event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      final updatedImages = List<String>.from(currentState.images)..add(event.imagePath);
      emit(currentState.copyWith(images: updatedImages));
    }
  }

  void _onRemoveImage(TaskPostingRemoveImage event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      final updatedImages = List<String>.from(currentState.images);
      if (event.index >= 0 && event.index < updatedImages.length) {
        updatedImages.removeAt(event.index);
        emit(currentState.copyWith(images: updatedImages));
      }
    }
  }

  Future<void> _onSubmit(TaskPostingSubmit event, Emitter<TaskPostingState> emit) async {
    if (state is! TaskPostingLoaded) return;

    final currentState = state as TaskPostingLoaded;
    
    if (!currentState.isFormComplete) {
      emit(TaskPostingError('Please fill in all required fields'));
      return;
    }

    emit(TaskPostingLoading());

    try {
      final task = Task(
        id: '', // Will be generated by the API
        title: currentState.title,
        summary: currentState.summary,
        category: currentState.category,
        subcategory: currentState.subcategory,
        location: currentState.location,
        budget: currentState.budget,
        preferredDate: currentState.preferredDate,
        images: currentState.images,
        status: 'pending',
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final createdTask = await createTask(task);
      emit(TaskPostingSuccess(createdTask));
    } catch (e) {
      emit(TaskPostingError('Failed to create task: ${e.toString()}'));
    }
  }

  void _onUpdateStep(TaskPostingUpdateStep event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      emit(currentState.copyWith(currentStep: event.step));
    }
  }

  void _onNextStep(TaskPostingNextStep event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      if (currentState.canProceedToNextStep && currentState.currentStep < 1) {
        emit(currentState.copyWith(currentStep: currentState.currentStep + 1));
      }
    }
  }

  void _onPreviousStep(TaskPostingPreviousStep event, Emitter<TaskPostingState> emit) {
    if (state is TaskPostingLoaded) {
      final currentState = state as TaskPostingLoaded;
      if (currentState.currentStep > 0) {
        emit(currentState.copyWith(currentStep: currentState.currentStep - 1));
      }
    }
  }

  void _onReset(TaskPostingReset event, Emitter<TaskPostingState> emit) {
    emit(TaskPostingLoaded());
  }
}
